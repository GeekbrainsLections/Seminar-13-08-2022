# Инструкция по работе с Git и с GitHub

## Что такое Git?
*Git* - одна из реализаций распределенных систем контроля версий, позволяющая организовать версионность, как локально, так и на удаленном сервере. Самая популярная платформа, реализующая *Git*, - [GitHub](Http://github.com) 

## Подготовка репозитария
Для создания в папке репозитория необходимо открыть эту папку в терминале и написать команду *git init*, после чего в этой папке создасться скрытая папка *.git*, и таким образом папка станет репозиторием

## Создание коммитов

### Просмотр состояния репозитория
Для просмотра состояния репозитория используется команда *git status*. В терминале с открытой папкой-репозиторием необходимо напмсать команду *git status*. В результате можно увидеть выводы:
1. On branch *** nohting to commit - это означает нет активных изменений
2. Untracked file - это означает, что имеются файлы, не отслеживаемые системой контроля версий
3. HEAD detached - это означает, что HEAD указывает не на вершину какой либо ветки, а просто на какой-то коммит

### Добавление файла к комиту
Для того, чтобы добавить файл к "сохранению", необходимо использовать  команду *git add*. В терминале с открытой папкой-репозиторием наобходимо написать *git add <название файла>*, и этот файл добавить к *сохранению*

### Создание фиксации
Для создания фиксации используется команда *git commit*. Для этого втерминале с папкой-репозиторием необходимо написать команду *git commit -m <сообщение к коммиту>*. Сообщение к коммиту писать **ОБЯЗАТЕЛЬНО**

## Журнал изменений
Для просмотра истории изменений используетсф команда *git log*. Для этого в терминале с папкой-репозиторием необходимо написать *git log*, и Вы увидете список всех коммитов  в этой ветке с описанием: имени, электронной почты, сообщением к соммиту и номер коммита. 

## Перемещение между коммитами
Для перемещениями между коммитами используется команда *git checkout <номер коммита>*. Номер коммита берется из журнала изменений.

## Ветки в Git
Ветка - это набор commit, которые идут друг за другом. У ветки есть название, основную ветку чаще всего называют master. Если говорить простыми словами, то ветка master - это наш проект.

Другие ветки - это отдельное место для реализации нового функционала или исправление багов (ошибок) нашего проекта. То есть, с отдельной веткой вы делаете что угодно, а затем сливаете эти изменения в основную ветку master.

Не рекомендую создавать commit напрямую в master . Лучше для этого заводить новую ветку и все изменения писать там.

Для того, чтобы создать новую ветку вводим:
git branch <название_ветки>

При создании новой ветки, старайтесь называть ее кратким и ёмким именем. 

Переключаться между ветками можно такой командой:

git checkout <название_ветки>

## Слияние веток и решение конфликтов

### Слияние веток

Master - это основная ветка пйроекта, в которую заливается только рабочий проверенный код. Новый функционал в конце концов оказывается в мастере. В этой ветке находится тот же самый код, что и на боевом сайте

Что такое *merge* или слияние веток - это перенос кода из одной ветки в другую. Например, когда мы заканчиваем работу над веткой, например, сделали новый функционал, мы сливаем ее в *master*.

Сливать друг в друга можно любые ветки. Технически, с точки зрения git нет никакой разницы, сливается ветка с новым функционалом в *master* или наоборот. Для нас *master* - это основная ветка разработки, а для git это просто ветка.

Следует четко различать *merge* своей ветки в *master* и *merge* *master(a)*  в свою ветку.

*Merge* ветки в *master*

Выполняется после завершения работы над своей веткой при помощи команды git merge. Чтобы вмерджить ветку в мастер, нужно сначала перейти в мастер, а затем выполнить git merge branch_name.

### Решение конфликтов

Системы контроля версий предназначены для управления дополнениями, вносимыми в проект множеством распределенных авторов (обычно разработчиков). Иногда один и тот же контент могут редактировать сразу несколько разработчиков. Если разработчик A попытается изменить код, который редактирует разработчик B, может произойти конфликт. Для предотвращения конфликтов разработчики работают в отдельных изолированных ветках. Основная задача команды git merge заключается в слиянии отдельных веток и разрешении любых конфликтующих правок.

Общие сведения о конфликтах слияния

Слияние и конфликты являются неотъемлемой частью работы с Git. В других инструментах управления версиями, например SVN, работа с конфликтами может быть дорогой и времязатратной. Git позволяет выполнять слияния очень просто. В большинстве случаев Git самостоятельно решает, как автоматически интегрировать новые изменения.

Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.

Типы конфликтов слияния

Конфликт во время слияния может произойти в двух отдельных точках — при запуске и во время процесса слияния. Далее рассмотрим, как разрешать каждый из этих конфликтных сценариев.

Git прерывает работу в самом начале слияния

Выполнение команды слияния прерывается в самом начале, если Git обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. Git не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд git stash, git checkout, git commit или git reset. Если команда слияния прерывается в самом начале, выдается следующее сообщение об ошибке:

    error: Entry '<fileName>' not uptodate. Cannot merge. (Changes in working directory)

Git прерывает работу во время слияния

Сбой В ПРОЦЕССЕ слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. Git сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную. При сбое во время выполнения слияния выдается следующее сообщение об ошибке: 

    error: Entry '<fileName>' would be overwritten by merge. Cannot merge. (Changes in staging area)

## Удаление веток

Удаление локальной ветки GIT

Чтобы удалить локальную ветку GIT, вы можете выполнить одну из следующих команд:

    git branch -d branch_name

    git branch -D branch_name

Как вы можете заметить, эти команды, в разных вариациях использования, имеют 2 разных аргумента, d и D.

Параметр -d означает --delete, который удалит локальную ветвь, только в случае, если вы смерджили её с какой-то из веток.

Опция -D обозначает --delete --force, которая удаляет ветку независимо от ее статуса push или merge, так что будьте осторожны при её использовании!

Удаление удалённой ветки GIT

Для того, чтобы удалить ветку, уже опубликованную в удалённом репозитории (например, в Bitbucket, GitHub, GitLab), вы можете использовать следующую команду:

    git push <remote_repository_name> --delete <branch_name>

Или же, есть ещё одна опция, которую, возможно, будет немного сложнее запомнить:

    git push <remote_repository_name> :<branch_name>

Эти основные параметры также могут быть использованы, если вы хотите удалить "тег".

В некоторых случаях бывает, что при попытке выполнить запрос на удаление ветки, получаем ошибку fatal: 'origin' does not appear to be a git repository fatal: Could not read from remote repository.
Это значит, что мы вводим неправильное имя удалённой ветки.

Это имя задаётся при добавлении удалённого репозитория к себе в проект. К примеру, выполняя эту команду на добавления удалённого репозитория он будет сохранён под именем origin:

    git remote add origin https://github.com/truehero/test.git

Но этот же репозиторий мы можем сохранить под любым другим именем, к примеру, выполнив команду:

    git remote add test_project https://github.com/truehero/test.git

Уже сможем обращаться к этому репозиторию по имени test_project.

Потому, чтобы избавиться от этой ошибки, достаточно либо сохранить этот репозиторий под именем origin, либо обращаться к этому репозиторию по его реальному имени.

Если вы получили такую ошибку, но не помните, какое имя вы присваивали этому репозиторию, выполните команду: git remote, которая покажет список актуальных удалённых репозиториев и их имена.

## Работа с удаленными репозиториями

Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

**git fetch**

Команда git fetch связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

**git pull**

Команда git pull работает как комбинация команд git fetch и git merge, т. е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

**git push**

Команда git push используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

**git remote**

Команда git remote служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например «origin», так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и git remote поможет добавлять, изменять и удалять их.

**git archive**

Команда git archive используется для упаковки в архив указанных коммитов или всего репозитория.

**git submodule**

Команда git submodule используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды submodule есть несколько под-команд — add, update, sync и др. — для управления такими репозиториями.
